//////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2017 Andreas Milton Maniotis
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//////////////////////////////////////////////////////////////////////////////////////////

namespace nargs   {
    
    template<typename... Args>
    struct signature
    {
	template<typename F, typename... PermutedArgs>
	static constexpr auto invoke(F&& f, PermutedArgs&&... perm_args);

	template<typename F>
	class invoker_t
	{
	public:
	    template<typename... PermutedArgs>
	    constexpr auto operator()(PermutedArgs&&... permuted_args) const

	};

	template<typename F>
	static constexpr invoker_t<F> invoker(F&& f);

	template<typename X>
	struct build
	{
	    template<typename... PermutedArgs>
	    static
	    X with(PermutedArgs && ... permuted_args);

	};

	template<typename X>
	struct builder
	{
	    template<typename... PermutedArgs>
	    constexpr X operator()(PermutedArgs&&... permuted_args) const;

	struct lax;
	struct strict;
    } ;
}

--------------------------------------------------------------------------------
PURPOSE:
--------------------------------------------------------------------------------

Provision of invokers and class builders for a fixed signature


--------------------------------------------------------------------------------
COMPILE TIME ASSERTIONS:
--------------------------------------------------------------------------------

signature<T_0, ... , T_r>  (0<= i <=r) leads to a compilation error if there are
two values i != j such that either Ti is statndard convertible into Tj or Tj is
standard convertible into Ti. (Then two named arguments collide).

--------------------------------------------------------------------------------
STATIC MEMBER FUNCTIONS:
--------------------------------------------------------------------------------

	template<typename... Args>
	template<typename F, typename... PermutedArgs>

	(1) constexpr auto
	    signature<Args...>::invoke<F&& f, PermutedArgs&&... perm_args);

	(2) constexpr auto
	    signature<Args...>::strict::invoke<F&& f, PermutedArgs&&... perm_args)

	(3) constexpr auto
	    signature<Args...>::lax::invoke(F&& f, PermutedArgs&&... perm_args);


	Let
	     Args...          = A_0, ... A_n
	     Permuted_Args... =	P_0, ... P_n

	Assume that the following conditions hold:

	(1) For each i (0 <= i <= n) there is exactly one number s(i)
	    such that P_i&& is standard-convertible into A_s(i)&&.

	(2) The mapping s : {0, ... n } --> {0, ... , n}
	    is a permutation.


	Consider the following calls:
	
	   (1) signature<Args...>::invoke(std::forward<F&&>(f),
	                                  P_0&& p_0, ... , P_n&& pn)

           and
	   
	   (2) signature<Args...>:: strict ::invoke(std::forward<F&&>(f),
					            P_0&& p_0, ... , P_n&& p_n);

        They evaluate to
	
	    std::invoke( std::forward<F&&>(f),
			 static_cast<A_s(0) &&>(p_s(0)),
			 ...
			 static_cast<A_s(n) &&>(p_s(n)) );


	The third call is slightly different:

   	    (3) signature<Args...>:: lax ::invoke(std::forward<F&&>(f),
					          P_0&& p_0, ... , P_n&& p_n);

        evaluates to
	
	    std::invoke( std::forward<F&&>(f),
			 static_cast<A_s(0) &&>( std::ref( p_s(0) ) ),
			 ...
			 static_cast<A_s(n) &&>( std::ref( p_s(n) ) ) );

	The difference is given in the acceptance of lvalue reference.
    	The first two calls do not admit any lvlaue refercence types
	P_i&& = P_i&, whereas the third call admits for lvalue references.


	The structs lax and strict in signature<Args...>::lax and
	signature<Args...>::strict define policies with respect to lvalue
	reference passing.

	The default policy (when strict / lax is not explicitly given) in (1)
	is forbidding direct lvalue references.

	The reason behind this choice is compatibility to std::invoke.
	
	Example for reference passing policies:

		int   i{};
		char* p{};
		
		auto f = [](int&, char*) { do_something.... };

		nargs::signature<int&, char>::
		                         invoke(std::move(f), p, i); // (1) ERROR

		nargs::signature<int&, char>::strict::
		                         invoke(std::move(f), p, i); // (2) ERROR

		nargs::signature<int&, char>::lax::
		                         invoke(std::move(f), p, i); // (3) GOOD

        The invocations (1) and (2) will not compile.					 


--------------------------------------------------------------------------------
REFERENCE-PASSING POLICIES:
--------------------------------------------------------------------------------

	nargs::signature<Args...>::strict
	nargs::signature<Args...>::lax
	
	Lvalue referencing policies: lax allows for lvalues to be passed
	directly whereas prohibits the direct passing of lvalue references.
	( They can still be passed, but they need explicit  wrapping
	via std::ref() ).

	Default policy: strict.

	nargs::signature<Args...> == nargs::signature<Args...>::strict

	
